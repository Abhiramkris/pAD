#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <LiquidCrystal_I2C.h>

// WiFi and Server Configuration
const char* SSID = "asdf";
const char* PASSWORD = "";
const char* SERVER_URL = "https://pad-ew3v.onrender.com"; // Your server URL

// LCD Display
LiquidCrystal_I2C lcd(0x27, 16, 2);

// Pin Definitions
#define MOTOR_ENA 5
#define MOTOR_IN1 18
#define MOTOR_IN2 19
#define HALL_SENSOR_PIN 21
#define IR_SENSOR_PIN 22

// System State
struct SystemState {
  int padCount;
  String paymentStatus;
  String systemStatus;
  bool dispensing;
} state;

// Motor Control Variables
volatile int hallTriggerCount = 0;
volatile bool irSensorTriggered = false;
unsigned long irSensorLastTriggered = 0;
unsigned long startTime = 0;

// Hall Sensor Interrupt
void IRAM_ATTR hallSensorISR() {
  hallTriggerCount++;
}

// Fetch System Status from Server
void fetchSystemStatus() {
  HTTPClient http;
  String url = String(SERVER_URL) + "/check";

  http.begin(url);
  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, payload);
    if (!error) {
      state.padCount = doc["padCount"];
      state.paymentStatus = doc["paymentStatus"].as<String>();
      state.systemStatus = doc["systemStatus"].as<String>();
      state.dispensing = doc["dispensing"];
    }
  } else {
    Serial.println("Error fetching system status");
  }

  http.end();
}

// Motor Control
void startMotor() {
  Serial.println("Starting motor...");
  Serial.printf("Hall Sensor Count: %d, IR Sensor Triggered: %s\n", 
                hallTriggerCount, 
                digitalRead(IR_SENSOR_PIN) == LOW ? "YES" : "NO");

  // Start motor
  digitalWrite(MOTOR_IN1, HIGH);
  digitalWrite(MOTOR_IN2, LOW);
  analogWrite(MOTOR_ENA, 128);

  // Wait 3 seconds for the motor to dispense
  delay(3000);

  // Stop motor
  analogWrite(MOTOR_ENA, 0);
  digitalWrite(MOTOR_IN1, LOW);
  digitalWrite(MOTOR_IN2, LOW);

  Serial.println("Motor stopped.");
}

// Update Pad Count (After IR Sensor Trigger)
void updatePadCount() {
  HTTPClient http;
  String url = String(SERVER_URL) + "/update-pad-count";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");

  String jsonBody = "{\"padCount\": " + String(state.padCount) + "}";
  int httpCode = http.POST(jsonBody);

  if (httpCode == 200) {
    String payload = http.getString();
    DynamicJsonDocument doc(1024);
    DeserializationError error = deserializeJson(doc, payload);
    if (!error) {
      state.padCount = doc["padCount"];
    }
  } else {
    Serial.println("Error updating pad count");
  }

  http.end();
}

// Refund Process
void processRefund() {
  Serial.println("Triggering refund...");

  HTTPClient http;
  String url = String(SERVER_URL) + "/refund";
  http.begin(url);
  http.addHeader("Content-Type", "application/json");

  String jsonBody = "{\"paymentId\": \"" + String(state.paymentStatus) + "\", \"reason\": \"Timeout or error\"}";
  int httpCode = http.POST(jsonBody);

  if (httpCode == 200) {
    Serial.println("Refund processed successfully");
    // Reset system after refund
    state.dispensing = false;
    hallTriggerCount = 0;
    irSensorTriggered = false;
  } else {
    Serial.println("Error processing refund");
  }

  http.end();
}

void setup() {
  Serial.begin(115200);
  WiFi.begin(SSID, PASSWORD);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("WiFi connected");

  pinMode(MOTOR_ENA, OUTPUT);
  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(HALL_SENSOR_PIN, INPUT_PULLUP);
  pinMode(IR_SENSOR_PIN, INPUT_PULLUP);

  // Fetch System Status from Server initially
  fetchSystemStatus();

  // If payment is successful, log the status and process motor
  if (state.paymentStatus == "success") {
    Serial.println("Payment success");
    Serial.println("Waiting for item to dispense...");
    startMotor();  // Start motor if payment is successful
    startTime = millis();  // Record the time when motor starts
  } else if (state.paymentStatus == "failed") {
    Serial.println("Payment failed, triggering refund...");
    processRefund();  // Trigger refund if payment failed
  }

  // Interrupt for Hall Sensor
  attachInterrupt(digitalPinToInterrupt(HALL_SENSOR_PIN), hallSensorISR, FALLING);
  delay(2000);
}

void loop() {
  // Continuously fetch System Status and update the display
  fetchSystemStatus();

  // Log Payment and Dispensing Status
  if (state.paymentStatus == "processing") {
    Serial.println("Payment processing...");
  }

  if (state.paymentStatus == "failed") {
    Serial.println("Payment failed!");
    // Here, we would trigger a refund if needed
  }

  if (state.dispensing) {
    Serial.println("Dispensing in progress...");
    Serial.printf("Hall Sensor Count: %d, IR Sensor Triggered: %s\n", 
                  hallTriggerCount, 
                  digitalRead(IR_SENSOR_PIN) == LOW ? "YES" : "NO");

    // Check IR sensor timeout (10 seconds)
    if (millis() - startTime > 10000 && hallTriggerCount == 0) {
      Serial.println("IR sensor timeout, initiating refund...");
      processRefund();  // Trigger refund if IR sensor is not triggered in 10 seconds and Hall sensor count is 0
    }

    // If Hall sensor count reaches 3, initiate refund
    if (hallTriggerCount >= 3) {
      Serial.println("Hall sensor count reached 3, initiating refund...");
      processRefund();
    }

    if (irSensorTriggered) {
      irSensorTriggered = false; // Reset the interrupt trigger flag
      Serial.println("IR sensor triggered. Updating pad count...");
      updatePadCount();
      Serial.println("Pad count updated.");
      delay(2000);  // Simulate waiting for item to dispense
    }
  } else {
    Serial.println("System is idle.");
  }

  // If dispensing has finished, stop motor and log it
  if (!state.dispensing) {
    Serial.println("Motor stopped.");
  }

  delay(1000);  // Polling delay
}

